/**
 * Helper methods that generate circulare paths so that the
 * single points of the path can be wobbled around
 */
#include "circle.h"

/**
 * Updates the points in a GPathInfo to reflect the parameters of the cirle_info and the wobblyness
 * @param info already initialized path
 * @param circle contains the information about the number of segments, color, centerpoint, ...
 * @param strength strength of the wobble; set to zero to disable wobble
 * @param time time of the wobble.
 */
void circle_warp(GPathInfo *info, cirle_info *circle, float strength, float time) {
    if (strength <= 0.01) {
        for (int i = 0; i < circle->num_points; ++i) {
            int angle = i * TRIG_MAX_ANGLE / circle->num_points;
            float relative_x = sin_lookup(angle) * circle->radius / TRIG_MAX_RATIO;
            float relative_y = cos_lookup(angle) * circle->radius / TRIG_MAX_RATIO;
            info->points[i].x = circle->center_x + relative_x;
            info->points[i].y = circle->center_y + relative_y;
        }
    } else {
        for (int i = 0; i < circle->num_points; ++i) {
            int angle = i * TRIG_MAX_ANGLE / circle->num_points;
            float relative_x = sin_lookup(angle) * circle->radius / TRIG_MAX_RATIO;
            float relative_y = cos_lookup(angle) * circle->radius / TRIG_MAX_RATIO;
            float distortion_x = noise(relative_x / 50.0f, relative_y / 50.0f, time) * strength;
            float distortion_y = noise(relative_x / 50.0f + 1000, relative_y / 50.0f + 1000, time) * strength;
            info->points[i].x = circle->center_x + relative_x + distortion_x;
            info->points[i].y = circle->center_y + relative_y + distortion_y;
        }
    }
}

/**
 * Generates a suitable GPathInfo to be used with the wobble function
 * @param info contains the number of segments n stuff
 * @return a non-nulled GPathInfo
 */
GPathInfo *cirle_create(cirle_info *info) {
    GPathInfo *path_info = malloc(sizeof(GPathInfo));
    path_info->num_points = info->num_points;

    GPoint *points = malloc(sizeof(GPoint) * info->num_points);
    path_info->points = points;
    circle_warp(path_info, info, 0.0f, 0.0f);
    return path_info;
}

/**
 * Frees a path generated by cirle_create()
 * @param info info to free
 */
void circle_destroy(GPathInfo *info) {
    free(info->points);
    free(info);
}
